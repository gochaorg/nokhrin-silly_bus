### 3. Списки и карты: Работа с коллекциями

[источник](https://github.com/gochaorg/blog/blob/master/itdocs/learn-java/01-proc.md#3-Списки-и-карты-Работа-с-коллекциями)

**Цель**: Хранить данные в `List` и `Map` (без углубления в ООП).

**Задания** (используют методы из п.2):

1. Найдите максимум и среднее в списке/массиве числе.
   - числа могут быть любые и сколько их в массиве не известно.

[реализация](ArrayOps.java)

#### уточнение требований
- параметры функции: функция принимает список или массив?
- какой результат ожидаем для пустого массива?
  - ноль?
  - ошибка?
- параметры функции: гарантируется ли гомогенность / что все элементы одного типа?
  - функция принимает `int[]`?
  - функция принимает `Integer[]`?
  - функция принимает `Object[]`?
- какое поведение ожидаем при обработке списка элементов смешанных типов?
  - обрабатываем все числа любых типов?
    - byte & int & double & float
  - обрабатываем все числа определенного типа?
    - byte | int | double | float
  - возможное решение - выделить функции для каждого типа
    - getMaxOfInts, getMaxOfFloats и тд
- какой тип возвращаемого значения функции?
  - `double`?
  - строка определенного формата?
    - какой формат?
    - например, сколько знаков после точки отображать

‼
- до уточнения
  - реализую обработку параметра типа `ArrayList<Object>`
  - полагаю непустой список обязательным параметром
  - валидацию аргументов реализую отдельным методом
  - привожу все числовые типы к `double`
  - реализую возвращаемое значение в виде строки `#.##`

#### рассуждения
- реализовал в виде статических методов по причинам:
  - нет задачи хранить состояние => не надо создавать объект => экономия памяти
  - легче понять структуру => меньше когнитивная нагрузка => дешевле поддерживать/развивать
- исходя из `числа могут быть любые и сколько их в массиве не известно` полагаю,
  - что передается массив произвольного размера
  - массив содержит объекты произвольного типа
  - применяю реализацию `ArrayList` интерфейса `List`, в свою очередь реализующего интерфейс `Collection`
    - цепочка наследования: `ArrayList` -> `List` -> `Collection` -> `Iterable`

---

2. Создайте `Map<String, Integer>` для пар «имя → возраст».

#### уточнение требований
- требуется создать интерфейс для хранения?
  - или метод, выполняющий запись значений в `Map`?
- в каком формате поступают значения `имя`, `возраст`?
  - по отдельности - строкой и числом соответственно?
  - по отдельности - строкой и строкой соответственно?
  - одной строкой с использованием разделителя?
    - какой разделитель?
- требуется ли сохранять порядок сортировки?
  - какой порядок сортировки требуется?
    - по алфавиту - по возрастанию значения поля `имя`?
    - по возрастанию значения поля `возраст`?
    - иначе?
- требуется ли записывать сформированный `Map` на диск?


---

## чему я научился
- понятия:
  - примитив
  - объект
  - коллекция примитивов / объектов
- ArrayList - динамический (то есть позволяющий объявлять массив, не указывая количество элементов) массив в Java
  - с примитивами работает только посредством обертки
  - аналог `list` в Python
- получать текстовое представление `int[]`
- представление о коллекциях
- преобразования `массив примитивов` -> `коллекция`
  - только со шпаргалкой, концепт не усвоил
- применять интерфейс `java.util.Map`
  - создал множества и отображения
- работать с группой типов в параметрах функции
  - когда гарантируется, что на вход передается число, но не уточняется подтип числа
  - то же для возвращаемого значения
- поверхностно попробовал `generic` при объявлении методов
  - `public static String getAvgValue(ArrayList<?> list)`


## вопросы
### в каком случае применять массив примитивов (например, `int[]`), в каком - массив объектов (например, `Integer[]`)?
- есть ли ситуации, в которых следует держаться примитивов?
  - То есть, в которых `int[]` лучше, чем  `Integer[]`
- есть ли ситуации, когда объекты предпочтительнее?

#### ответ

> int[] - предпочтительнее Integer[], но не всегда уместно
> 
> предпочтительнее
> 1) int[] - представлен как один сплошой массив байтов по 4 штуки байт на элемент - т.е. занимает меньше
> 2) Integer[] - массив ссылок на объекты типа Integer
>    a) надежность ниже, т.к. ссылка внутри такого массива может быть null
>    б) скорость - при доступе отдельному элементу - двойное чтение, прочитать ссылку -> прочитать значение по ссылке
>    в целом эта схема медленно работает еще из-за кеша процессора (любого)
> 
> ради скорости все делать не надо, это не всегда оправдано

---

### следует ли указывать тип элемента в <> инициализатора?
`ArrayList<Integer> listOfInts = new ArrayList<Integer>(Arrays.asList(1, 2, 3, 4, 5));` или
`ArrayList<Integer> listOfInts = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));` ?

#### ответ
> ArrayList<Integer> variable = new ArrayList<Integer>()
> 
> тут на лицо излишний код, в ранних версиях это было необходимо
> текущий компилятор java способен в этом случае
> 
> ArrayList<Integer> variable = new ArrayList<>()
> 
> дописать код сам, до
> 
> ArrayList<Integer> varaible = new ArrayList<Integer>()
> 
> это он и делает
> можно еще короче
> 
> var variable = new ArrayList<Integer>()
> 
> компилятор по факту его перепишет в это
> 
> ArrayList<Integer> varaible = new ArrayList<Integer>()



---

### когда пишу метод, задаюсь вопросами

1. при некорректных значениях параметров, должен ли метод завершить выполнение?
- в этом случае как принято поступать в общем случае, если нет конкретной договоренности?
- уточнить требования/описать контракт?
- выбросить исключение?
- вернуть условный код выхода?

2. при некорректных значениях параметров, должен ли метод "подстроиться" под данные/вызывающую сторону?
- то есть, выполнить работу не вызывая ошибки
- например, поймать исключение о невалидном значении параметра и вернуть `null`
- в случае отлова исключения следует ли уведомлять пользователя о пойманном исключении?
  - или это отладочная инфа только для разработчика?

#### ответ
>


---

### значения параметров метода могут быть разных типов

- допустима ли такая ситуация?
  - интуитивно считаю, что надеженее код, которому гарантируется тип данных
    - например, `public static String getNumber(Object n)`
    - `n` - по условию - принадлежит одному из числовых типов, тип не уточняется
  - решение вижу в создании метода для каждого типа данных
    - например, 
      - `public static String getInt(int n)`
      - `public static String getDouble(doulbe n)`
  - в вызывающей процедуре 
    - либо ловить исключения, 
    - либо проверять тип с помощью `instanceof` и вызывать метод для реально полученного типа

#### ответ
>

---

### тип данных элементов списка
- корректно ли описание типа `ArrayList<?>` ?
  - именно `знак вопроса <?>`

---


## **Контрольные вопросы**:
- ❓ Почему `map.get("Alex")` вернет `null` для ключа `"alex"`?
  - ключи словаря/мапы регистрочуствительны, так как завязаны на результат вычисления хэш-функции
    - `"alex"` и `"Alex"` имеют разные хэши
    - для несуществующего ключа метод `get` по умолчанию возвращает `null`
- ❓ Как удалить дубликаты через `new HashSet<>(list)`?
  - HashSet - имплементирует математическое множество, в нем по определению нет дубликатов

